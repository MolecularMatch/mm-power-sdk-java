/*
 * MolecularMatch MMPower
 * MMPower API
 *
 * OpenAPI spec version: 1.0.0
 * Contact: support@molecularmatch.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package io.swagger.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
/**
 * AssertionSources
 */


public class AssertionSources {
  @SerializedName("id")
  private String id = null;

  /**
   * Type of clinical evidence associated with publication.
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    TRIAL("trial"),
    CASE_STUDY("case_study"),
    PRECLINICAL("preclinical"),
    EXPERT("expert"),
    PATHWAY_INFERRED("pathway_inferred"),
    INSTITUTIONAL_STUDY("institutional_study"),
    REGULATORY("regulatory"),
    SEQUENCING("sequencing"),
    EMPTY("");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String text) {
      for (TypeEnum b : TypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return TypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = null;

  /**
   * A more specific sub type of clinical evidence associated with publication.
   */
  @JsonAdapter(SubTypeEnum.Adapter.class)
  public enum SubTypeEnum {
    PROSPECTIVE("prospective"),
    RETROSPECTIVE("retrospective"),
    META_ANALYSIS("meta_analysis"),
    CLINICAL("clinical"),
    RESEARCHER("researcher"),
    CELL_LINE("cell_line"),
    PDX("pdx"),
    BIOCHEMICAL_ASSAY("biochemical_assay"),
    MOUSE_MODEL("mouse_model");

    private String value;

    SubTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static SubTypeEnum fromValue(String text) {
      for (SubTypeEnum b : SubTypeEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<SubTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SubTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SubTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return SubTypeEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("subType")
  private SubTypeEnum subType = null;

  @SerializedName("pubId")
  private String pubId = null;

  @SerializedName("trialId")
  private String trialId = null;

  @SerializedName("trialPhase")
  private String trialPhase = null;

  /**
   * Change to function of biomarker.
   */
  @JsonAdapter(FunctionalConsequenceEnum.Adapter.class)
  public enum FunctionalConsequenceEnum {
    LOSS_OF_FUNCTION("loss_of_function"),
    GAIN_OF_FUNCTION("gain_of_function"),
    UNCHARACTERIZED("uncharacterized"),
    INCONCLUSIVE("inconclusive");

    private String value;

    FunctionalConsequenceEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static FunctionalConsequenceEnum fromValue(String text) {
      for (FunctionalConsequenceEnum b : FunctionalConsequenceEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<FunctionalConsequenceEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FunctionalConsequenceEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FunctionalConsequenceEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return FunctionalConsequenceEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("functionalConsequence")
  private FunctionalConsequenceEnum functionalConsequence = null;

  /**
   * Name of publication index if applicable.
   */
  @JsonAdapter(NameEnum.Adapter.class)
  public enum NameEnum {
    PUBMED("PUBMED"),
    AACR("AACR"),
    ASCO("ASCO"),
    ESMO("ESMO"),
    ASCOMEETING("ASCOMEETING");

    private String value;

    NameEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static NameEnum fromValue(String text) {
      for (NameEnum b : NameEnum.values()) {
        if (String.valueOf(b.value).equals(text)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<NameEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NameEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NameEnum read(final JsonReader jsonReader) throws IOException {
        String value = jsonReader.nextString();
        return NameEnum.fromValue(String.valueOf(value));
      }
    }
  }  @SerializedName("name")
  private NameEnum name = null;

  @SerializedName("link")
  private String link = null;

  @SerializedName("year")
  private Integer year = null;

  @SerializedName("trustRating")
  private Float trustRating = null;

  public AssertionSources id(String id) {
    this.id = id;
    return this;
  }

   /**
   * Unique source identifier for this assertion.
   * @return id
  **/
  @Schema(required = true, description = "Unique source identifier for this assertion.")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public AssertionSources type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Type of clinical evidence associated with publication.
   * @return type
  **/
  @Schema(description = "Type of clinical evidence associated with publication.")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public AssertionSources subType(SubTypeEnum subType) {
    this.subType = subType;
    return this;
  }

   /**
   * A more specific sub type of clinical evidence associated with publication.
   * @return subType
  **/
  @Schema(description = "A more specific sub type of clinical evidence associated with publication.")
  public SubTypeEnum getSubType() {
    return subType;
  }

  public void setSubType(SubTypeEnum subType) {
    this.subType = subType;
  }

  public AssertionSources pubId(String pubId) {
    this.pubId = pubId;
    return this;
  }

   /**
   * A publication identifier.
   * @return pubId
  **/
  @Schema(description = "A publication identifier.")
  public String getPubId() {
    return pubId;
  }

  public void setPubId(String pubId) {
    this.pubId = pubId;
  }

  public AssertionSources trialId(String trialId) {
    this.trialId = trialId;
    return this;
  }

   /**
   * A clinical trial identifier.
   * @return trialId
  **/
  @Schema(description = "A clinical trial identifier.")
  public String getTrialId() {
    return trialId;
  }

  public void setTrialId(String trialId) {
    this.trialId = trialId;
  }

  public AssertionSources trialPhase(String trialPhase) {
    this.trialPhase = trialPhase;
    return this;
  }

   /**
   * A clinical trial phase.
   * @return trialPhase
  **/
  @Schema(description = "A clinical trial phase.")
  public String getTrialPhase() {
    return trialPhase;
  }

  public void setTrialPhase(String trialPhase) {
    this.trialPhase = trialPhase;
  }

  public AssertionSources functionalConsequence(FunctionalConsequenceEnum functionalConsequence) {
    this.functionalConsequence = functionalConsequence;
    return this;
  }

   /**
   * Change to function of biomarker.
   * @return functionalConsequence
  **/
  @Schema(description = "Change to function of biomarker.")
  public FunctionalConsequenceEnum getFunctionalConsequence() {
    return functionalConsequence;
  }

  public void setFunctionalConsequence(FunctionalConsequenceEnum functionalConsequence) {
    this.functionalConsequence = functionalConsequence;
  }

  public AssertionSources name(NameEnum name) {
    this.name = name;
    return this;
  }

   /**
   * Name of publication index if applicable.
   * @return name
  **/
  @Schema(description = "Name of publication index if applicable.")
  public NameEnum getName() {
    return name;
  }

  public void setName(NameEnum name) {
    this.name = name;
  }

  public AssertionSources link(String link) {
    this.link = link;
    return this;
  }

   /**
   * A URL to publication if available.
   * @return link
  **/
  @Schema(description = "A URL to publication if available.")
  public String getLink() {
    return link;
  }

  public void setLink(String link) {
    this.link = link;
  }

  public AssertionSources year(Integer year) {
    this.year = year;
    return this;
  }

   /**
   * Year of publication.
   * @return year
  **/
  @Schema(description = "Year of publication.")
  public Integer getYear() {
    return year;
  }

  public void setYear(Integer year) {
    this.year = year;
  }

  public AssertionSources trustRating(Float trustRating) {
    this.trustRating = trustRating;
    return this;
  }

   /**
   * A subjective assessment of evidence quality.
   * @return trustRating
  **/
  @Schema(description = "A subjective assessment of evidence quality.")
  public Float getTrustRating() {
    return trustRating;
  }

  public void setTrustRating(Float trustRating) {
    this.trustRating = trustRating;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AssertionSources assertionSources = (AssertionSources) o;
    return Objects.equals(this.id, assertionSources.id) &&
        Objects.equals(this.type, assertionSources.type) &&
        Objects.equals(this.subType, assertionSources.subType) &&
        Objects.equals(this.pubId, assertionSources.pubId) &&
        Objects.equals(this.trialId, assertionSources.trialId) &&
        Objects.equals(this.trialPhase, assertionSources.trialPhase) &&
        Objects.equals(this.functionalConsequence, assertionSources.functionalConsequence) &&
        Objects.equals(this.name, assertionSources.name) &&
        Objects.equals(this.link, assertionSources.link) &&
        Objects.equals(this.year, assertionSources.year) &&
        Objects.equals(this.trustRating, assertionSources.trustRating);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, type, subType, pubId, trialId, trialPhase, functionalConsequence, name, link, year, trustRating);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AssertionSources {\n");
    
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    subType: ").append(toIndentedString(subType)).append("\n");
    sb.append("    pubId: ").append(toIndentedString(pubId)).append("\n");
    sb.append("    trialId: ").append(toIndentedString(trialId)).append("\n");
    sb.append("    trialPhase: ").append(toIndentedString(trialPhase)).append("\n");
    sb.append("    functionalConsequence: ").append(toIndentedString(functionalConsequence)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    link: ").append(toIndentedString(link)).append("\n");
    sb.append("    year: ").append(toIndentedString(year)).append("\n");
    sb.append("    trustRating: ").append(toIndentedString(trustRating)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
